<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Live Bus Tracking</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
    <link rel="stylesheet" href="static/dropdown.css">
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.js"></script>
    <script src="static/routes_polyline.js"></script>
    <script src="static/tripMaps.js"></script>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon-32.png') }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        #map {
            height: 100vh;
            width: 100vw;
        }

        #selectBus {
            position: absolute;
            top: 10px;
            left: 70px;
            z-index: 1000;
            background: white;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div id="selectBus" class="green-theme">
        <select id="routeDropdown">
            <option value="">Select a route</option>
        </select>
        <select id="headsignDropdown">
            <option value="">Select a headsign</option>
        </select>
    </div>
    <div id="map"></div>
    <script>
        var map = L.map('map', {
            zoomControl: true,
            tap: true
        }).setView([48.476165, -123.332778], 12);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        const socket = io.connect('http://' + document.domain + ':' + location.port);

        //socket.onAny((ev, data) => console.log('[onAny]', ev, data));
        //socket.on('connect', () => console.log('[socket] connected'));
        //socket.on('vehicle_update', d => console.log('[vehicle_update]', d));

        //socket.on('vehicle_tick', d => console.log('[tick]', d));


        var markers = {};
        var polylineLayers = {};
        var selectedHeadsign = '';
        //var routeToDirections = {};
        let selectedRouteId = '';
        let selectedDirectionId = null;


        // Organize route to headsigns from GeoJSON
        /*
        routes_polyline.features.forEach(feature => {
            const { route_id, headsign } = feature.properties;

            function normalize(text) {
                return text
                    .toLowerCase()
                    .replace(/-/g, '')            // remove dashes
                    .replace(/\s+/g, ' ')         // normalize spaces
                    .replace(/via/g, '')          // optionally remove "via"
                    .trim();
            }

            const tripEntry = Object.values(tripIdMap).find(t =>
                t.route_id === route_id &&
                normalize(t.headsign) === normalize(headsign)
            );

            if (!tripEntry) {
                console.warn(`Missing direction ID for headsign "${headsign}" and route "${route_id}"`);
                //return;
                return;
            }

            const direction_id = tripEntry.direction_id;
            feature.properties.direction_id = direction_id;

            if (!routeToDirections[route_id]) {
                routeToDirections[route_id] = {};
            }
            routeToDirections[route_id][direction_id] = headsign;
        });
        */
        function norm(s) {
            return (s || "").toLowerCase()
                .replace(/[-]/g, "")            // remove dashes
                .replace(/\s+/g, " ")         // normalize spaces
                //.replace(/via/g, '')          // optionally remove "via"
                .trim();
        }

        function onLocationFound(e) {
            const radius = e.accuracy;

            L.marker(e.latlng).addTo(map)
                .bindPopup("You are within " + radius + " meters from this point").openPopup();

            L.circle(e.latlng, radius).addTo(map);
        }
        map.on('locationfound', onLocationFound);

        function resolveDir(route_id, rawHeadsign) {
            const table = headsignDirMajority[route_id];
            if (!table) return null;
            const n = norm(rawHeadsign);
            if (table[n]) return table[n].dir;

            //soft fallback 
            const nNoVia = n.replace(/\s*-\s*via .*$/i, "");
            if (table[nNoVia]) return table[nNoVia].dir;

            const nNoOnly = n.replace(/\s+only$/i, "");
            if (table[nNoOnly]) return table[nNoOnly].dir;

            return null;
        }

        routes_polyline.features.forEach(feature => {
            const p = feature.properties || {};
            if (!p.route_id || !p.headsign) return;
            const d = resolveDir(p.route_id, p.headsign);
            if (d !== null) p.direction_id = d
        });

        // Populate route dropdown
        const routeDropdown = document.getElementById("routeDropdown");
        routeDropdown.innerHTML = '<option value="">Select a route</option>';
        Object.keys(routeToDirections).sort().forEach(route_id => {
            const option = document.createElement("option");
            option.value = route_id;
            option.textContent = route_id;
            routeDropdown.appendChild(option);
        });

        // Populate headsigns on route selection
        routeDropdown.addEventListener("change", e => {
            selectedRouteId = e.target.value;
            //const headsigns = routeToDirections[selectedRouteId];

            const headsignDropdown = document.getElementById("headsignDropdown");
            headsignDropdown.innerHTML = '<option value="">Select a headsign</option>';

            const dirs = routeToDirections[selectedRouteId] || {};

            Object.keys(dirs).sort().forEach(dir => {
                dirs[dir].forEach(headsign => {
                    const option = document.createElement("option");
                    option.value = dir;
                    option.textContent = headsign;
                    headsignDropdown.appendChild(option);
                });
            });

        });


        document.getElementById("headsignDropdown").addEventListener("change", function (e) {
            selectedDirectionId = parseInt(e.target.value);

            //Remove all existing polylines
            Object.values(polylineLayers).flat().forEach(p => map.removeLayer(p));
            polylineLayers = {};

            //Remove all existing markers
            Object.values(markers).forEach(m => map.removeLayer(m));


            //Draw polyline(s) for the selected route + direction
            let key = `${selectedRouteId}_${selectedDirectionId}`;
            polylineLayers[key] = [];

            routes_polyline.features.forEach(feature => {
                const props = feature.properties;
                if (props.route_id === selectedRouteId && props.direction_id === selectedDirectionId) {
                    const polyline = L.geoJSON(feature).addTo(map);
                    polylineLayers[key].push(polyline); //push to the array
                }
            });
        });



        socket.on('vehicle_update', function (data) {
            const {
                latitude, longitude, vehicle_id,
                vehicle_seats, vehicle_speed, trip_id
            } = data;
            if (latitude == null || longitude == null || !vehicle_id) {
                console.warn('[BUS] missing basics', { latitude, longitude, vehicle_id });
                return;
            }
            //console.log("Known trip_ids:", Object.keys(tripIdMap).slice(0, 10)); // Just show some


            const tripInfo = tripIdMap[trip_id];
            if (!tripInfo) {
                //console.warn("Trip ID not found in IDMap", trip_id);
                return;
            }


            const route_id = tripInfo.route_id;
            const direction_id = tripInfo.direction_id;
            const headsign = tripInfo.headsign;


            if (!markers[vehicle_id]) {
                const busIcon = L.icon({
                    iconUrl: 'static/favicon-32.png',
                    iconSize: [20, 29],
                    //iconUrl: "{{ url_for('static', filename='favicon-32.png') }}",
                    //iconRetinaUrl: "{{ url_for('static', filename='favicon-32.png') }}",
                    iconAnchor: [10, 29],
                    popupAnchor: [0, -29],
                });

                markers[vehicle_id] = L.marker([latitude, longitude], {
                    icon: busIcon
                }).bindPopup(
                    `Headsign: ${headsign}<br>Direction: ${direction_id}<br>Occupancy Level: ${vehicle_seats}<br>Vehicle Speed: ${vehicle_speed}`
                );
            } else {
                markers[vehicle_id].setLatLng([latitude, longitude]);
                markers[vehicle_id].setPopupContent(`Headsign: ${headsign}<br>Direction: ${direction_id}<br>Occupancy Level: ${vehicle_seats}<br>Vehicle Speed: ${vehicle_speed}`);
            }

            if (
                route_id === selectedRouteId &&
                direction_id === selectedDirectionId
            ) {
                map.addLayer(markers[vehicle_id]);
            } else {
                map.removeLayer(markers[vehicle_id]);
            }
        });

    </script>
</body>

</html>